// Package exploit provides functions to execute exploits and manage their output.
package exploit

import (
	"bufio"
	"fmt"
	"io"
	"os/exec"
	"runtime"
	"strconv"
	"sync"

	"github.com/ByteTheCookies/CookieFarm/internal/client/config"
	"github.com/ByteTheCookies/CookieFarm/internal/client/websockets"
	"github.com/ByteTheCookies/CookieFarm/pkg/logger"
	"github.com/ByteTheCookies/CookieFarm/pkg/models"
)

type ExecutionResult struct {
	Cmd        *exec.Cmd
	FlagsChan  chan models.Flag
	OutputChan chan string
	stopReader chan struct{}
	done       chan struct{}
}

var (
	GlobalResult *ExecutionResult
	MutexResult  sync.Mutex
)

// Start starts the exploit_manager and listens for flags in stdout.
func Start(exploitPath string, tickTime int, threadCount int, port uint16) (*ExecutionResult, error) {
	cm := config.GetConfigManager()
	logger.Log.Debug().
		Str("exploitPath", exploitPath).
		Int("tickTime", tickTime).
		Int("threadCount", threadCount).
		Uint16("port", port).
		Str("Host", cm.GetLocalConfig().Host+":"+strconv.Itoa(int(cm.GetLocalConfig().Port))).
		Msg("Starting exploit with parameters")
	var cmd *exec.Cmd
	if runtime.GOOS == "windows" {
		cmd = exec.Command(
			"python",
			exploitPath,
			cm.GetLocalConfig().Host+":"+strconv.Itoa(int(cm.GetLocalConfig().Port)),
			strconv.Itoa(tickTime),
			strconv.Itoa(threadCount),
			strconv.Itoa(int(port)),
			cm.MapPortToService(port),
		)
	} else {
		cmd = exec.Command(
			exploitPath,
			cm.GetLocalConfig().Host+":"+strconv.Itoa(int(cm.GetLocalConfig().Port)),
			strconv.Itoa(tickTime),
			strconv.Itoa(threadCount),
			strconv.Itoa(int(port)),
			cm.MapPortToService(port),
		)
	}

	logger.Log.Debug().
		Str("full path exploit", exploitPath).
		Int("tick time", tickTime).
		Str("command executed", cmd.String())

	logger.Log.Info().Msg("Starting exploiting process with exploit_manager...")

	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return nil, fmt.Errorf("failed to get stdout pipe: %w", err)
	}

	stderr, err := cmd.StderrPipe()
	if err != nil {
		return nil, fmt.Errorf("failed to get stderr pipe: %w", err)
	}

	if err := cmd.Start(); err != nil {
		return nil, fmt.Errorf("failed to start command: %w", err)
	}

	flagsChan := make(chan models.Flag, 500)
	outputChan := make(chan string, 100) // Buffer for real-time output
	stopReader := make(chan struct{})
	done := make(chan struct{})

	go readStdout(stdout, flagsChan, outputChan, stopReader, done)
	go readStderr(stderr, outputChan, stopReader, done)

	return &ExecutionResult{
		Cmd:        cmd,
		FlagsChan:  flagsChan,
		OutputChan: outputChan,
		stopReader: stopReader,
		done:       done,
	}, nil
}

func RestartGlobal() {
	cm := config.GetConfigManager()
	MutexResult.Lock()
	defer MutexResult.Unlock()

	if GlobalResult != nil {
		logger.Log.Info().Msg("Stopping existing exploit...")
		_ = GlobalResult.Shutdown()
	}

	logger.Log.Info().Msg("Starting new exploit process...")

	result, err := Start(
		cm.GetArgsAttackInstance().ExploitPath,
		cm.GetArgsAttackInstance().TickTime,
		cm.GetArgsAttackInstance().ThreadCount,
		cm.GetArgsAttackInstance().ServicePort,
	)
	if err != nil {
		logger.Log.Fatal().Err(err).Msg("Failed to start new exploit")
	}

	GlobalResult = result

	go func() {
		if err := result.Cmd.Wait(); err != nil {
			logger.Log.Error().Err(err).Msg("Exploit process exited with error")
		}
	}()

	go func() {
		err := websockets.Start(result.FlagsChan)
		if err != nil {
			logger.Log.Error().Err(err).Msg("Submitter exited with error")
		}
	}()
}

// Shutdown end	the exploit process.
func (e *ExecutionResult) Shutdown() error {
	logger.Log.Info().Msg("Shutting down exploit...")

	if err := e.Cmd.Process.Kill(); err != nil {
		return fmt.Errorf("failed to kill exploit process: %w", err)
	}

	close(e.stopReader)
	<-e.done

	close(e.FlagsChan)
	close(e.OutputChan)

	logger.Log.Info().Msg("Exploit shutdown completed.")
	return nil
}

// LogParsedLineError logs an error based on the status and line.
func logParsedLineError(err error, status, line string) {
	switch status {
	case "fatal":
		logger.Log.Fatal().Err(err).Msg("Fatal error")
	case "info":
		logger.Log.Info().Err(err).Msg("Info")
	case "failed":
		logger.Log.Warn().Err(err).Msg("Failed to run exploit")
	default:
		logger.Log.Debug().Err(err).Msg("Parsing warning")
	}
	logger.Log.Debug().Str("raw", line).Msg("Raw line with error")
}

// Read the stdout and parse JSON lines into Flag structs.
func readStdout(stdout io.Reader, flagsChan chan<- models.Flag, outputChan chan<- string, stop <-chan struct{}, done chan<- struct{}) {
	defer func() { done <- struct{}{} }()

	scanner := bufio.NewScanner(stdout)
	for scanner.Scan() {
		select {
		case <-stop:
			logger.Log.Info().Msg("readStdout received shutdown signal")
			return
		default:
			line := scanner.Text()

			select {
			case outputChan <- "STDOUT: " + line:
				// Successfully sent to output channel
			default:
				// Channel buffer full, continue without blocking
			}

			flag, status, err := ParseLine(line)
			if err != nil {
				logParsedLineError(err, status, line)
				continue
			}
			flagsChan <- flag
			logger.Log.Info().
				Str("flag", flag.FlagCode).
				Int("team", int(flag.TeamID)).
				Str("service", flag.ServiceName).
				Uint16("port", flag.PortService).
				Msg("Parsed and queued flag")
		}
	}
	if err := scanner.Err(); err != nil {
		logger.Log.Error().Err(err).Msg("Error reading stdout scanner")
	}
}

// Read the stderr and log any errors.
func readStderr(stderr io.Reader, outputChan chan<- string, stop <-chan struct{}, done chan<- struct{}) {
	defer func() { done <- struct{}{} }()

	scanner := bufio.NewScanner(stderr)
	for scanner.Scan() {
		select {
		case <-stop:
			logger.Log.Info().Msg("readStderr received shutdown signal")
			return
		default:
			line := scanner.Text()

			select {
			case outputChan <- "STDERR: " + line:
				// Successfully sent to output channel
			default:
				// Channel buffer full, continue without blocking
			}

			logger.Log.Warn().Str("stderr", line).Msg("Exploit stderr")
		}
	}
	if err := scanner.Err(); err != nil {
		logger.Log.Error().Err(err).Msg("Error reading stderr scanner")
	}
}
