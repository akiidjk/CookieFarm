package exploit

import (
	"errors"
	"fmt"
	"os"
	"os/signal"
	"path/filepath"
	"slices"
	"strings"
	"syscall"

	"github.com/ByteTheCookies/CookieFarm/internal/client/config"
	"github.com/ByteTheCookies/CookieFarm/internal/client/filesystem"
	"github.com/ByteTheCookies/CookieFarm/internal/client/websockets"
	"github.com/ByteTheCookies/CookieFarm/pkg/logger"
)

// ============================================================================
// TYPES AND STRUCTURES
// ============================================================================

// StreamingResult contains the result channels for RunFuncTui
type StreamingResult struct {
	OutputChan chan string
	ErrorChan  chan error
	ExitChan   chan struct{}
	PID        int
}

// ============================================================================
// EXPLOIT EXECUTION FUNCTIONS
// ============================================================================

// Run executes the exploit with the given parameters and returns a StreamingResult
func Run(exploitPath string, tickTime int, threads int, servicePort uint16) (*StreamingResult, error) {
	cm := config.GetConfigManager()
	cm.SetArgsAttackInstance(config.ArgsAttack{
		ExploitPath: exploitPath,
		TickTime:    tickTime,
		ThreadCount: threads,
		ServicePort: servicePort,
	})

	logger.Log.Debug().Str("ExploitPath", cm.GetArgsAttackInstance().ExploitPath).
		Int("TickTime", cm.GetArgsAttackInstance().TickTime).
		Int("ThreadCount", cm.GetArgsAttackInstance().ThreadCount).
		Uint16("ServicePort", cm.GetArgsAttackInstance().ServicePort).
		Msg("Starting exploit execution with parameters")

	outputChan := make(chan string, 100) // Buffer for output messages
	errorChan := make(chan error, 10)    // Buffer for errors
	exitChan := make(chan struct{})      // Signal when process exits

	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-c
		logger.Log.Info().Msg("Shutting down gracefully...")
		if cm.GetPID() != 0 {
			Cleanup(cm.GetPID())
		}
		close(exitChan)
	}()

	if err := Setup(true); err != nil {
		logger.Log.Error().Err(err).Msg("Initialization error")
		return nil, fmt.Errorf("initialization error: %v", err)
	}

	outputChan <- "Client initialized successfully"
	logger.Log.Info().Msg("Client initialized successfully")

	result, err := Start(
		cm.GetArgsAttackInstance().ExploitPath,
		tickTime,
		threads,
		servicePort,
	)
	if err != nil {
		logger.Log.Error().Err(err).Msg("Failed to execute exploit")
		return nil, fmt.Errorf("failed to execute exploit: %v", err)
	}

	exploitS := config.Exploit{
		Name: exploitPath,
		PID:  result.Cmd.Process.Pid,
	}
	localConfig := cm.GetLocalConfig()
	localConfig.Exploits = append(localConfig.Exploits, exploitS)
	cm.SetLocalConfig(localConfig)

	if err := cm.WriteLocalConfigToFile(); err != nil {
		logger.Log.Error().Err(err).Msg("Failed to write configuration")
		return nil, fmt.Errorf("failed to write configuration: %v", err)
	}

	cm.SetPID(result.Cmd.Process.Pid)

	outputChan <- fmt.Sprintf("Exploit started with PID: %d", cm.GetPID())
	outputChan <- fmt.Sprintf("Running on port %d: %s", servicePort, cm.MapPortToService(servicePort))
	outputChan <- fmt.Sprintf("Threads: %d, Tick time: %d seconds", threads, tickTime)
	outputChan <- "Output streaming started..."

	websockets.OnNewConfig = func() {
		RestartGlobal()
		outputChan <- "Configuration updated, restarting exploit..."
	}

	go websockets.Start(result.FlagsChan)

	go func() {
		defer close(outputChan)
		defer close(errorChan)
		defer close(exitChan)

		for {
			select {
			case line, ok := <-result.OutputChan:
				if !ok {
					outputChan <- "Output channel closed"
					return
				}
				outputChan <- line
			case <-exitChan:
				return
			}
		}
	}()

	go func() {
		if err := result.Cmd.Wait(); err != nil {
			errorMsg := fmt.Sprintf("Exploit process exited with error: %v", err)
			logger.Log.Error().Err(err).Msg("Exploit process exited with error")
			errorChan <- errors.New(errorMsg)
			outputChan <- "ERROR: " + errorMsg
		} else {
			outputChan <- "Exploit process completed successfully"
		}
		exitChan <- struct{}{}
	}()

	return &StreamingResult{
		OutputChan: outputChan,
		ErrorChan:  errorChan,
		ExitChan:   exitChan,
		PID:        cm.GetPID(),
	}, nil
}

// ============================================================================
// EXPLOIT FILE MANAGEMENT FUNCTIONS
// ============================================================================

// Create creates a new exploit template file with the given name
func Create(name string) (string, error) {
	path := config.DefaultConfigPath
	if _, err := os.Stat(config.DefaultConfigPath); os.IsNotExist(err) {
		logger.Log.Warn().Msg("Default exploit path not exists... Creating it")
		err := os.MkdirAll(config.DefaultConfigPath, os.ModePerm)
		if err != nil {
			return "", fmt.Errorf("error creating exploit path: %v", err)
		}
	}

	logger.Log.Debug().Str("Exploit name", name).Msg("Creating exploit template")

	namePathNormalized, err := filesystem.NormalizeNamePathExploit(name)
	if err != nil {
		return "", fmt.Errorf("error normalizing exploit name: %v", err)
	}

	if filesystem.IsPath(namePathNormalized) {
		path = namePathNormalized
	} else {
		exploitsDir := filepath.Join(path, "exploits")
		if _, err := os.Stat(exploitsDir); os.IsNotExist(err) {
			logger.Log.Warn().Msg("Exploits directory does not exist, creating it")
			os.Mkdir(exploitsDir, os.ModePerm)
		}
		path = filepath.Join(exploitsDir, namePathNormalized)
	}

	exploitFile, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_SYNC, 0o777)
	if err != nil {
		return "", fmt.Errorf("error creating exploit file: %v", err)
	}
	exploitFile.Write(config.ExploitTemplate)
	defer exploitFile.Close()

	return "Exploit file created successfully at " + path, nil
}

// Remove deletes an existing exploit template file with the given name
func Remove(name string) (string, error) {
	path := config.DefaultConfigPath
	if _, err := os.Stat(config.DefaultConfigPath); os.IsNotExist(err) {
		logger.Log.Warn().Msg("Default exploit path not exists... Creating it")
		err := os.MkdirAll(config.DefaultConfigPath, os.ModePerm)
		if err != nil {
			return "", fmt.Errorf("error removing exploit path: %v", err)
		}
	}

	logger.Log.Debug().Str("Exploit name", name).Msg("Removing exploit template")

	namePathNormalized, err := filesystem.NormalizeNamePathExploit(name)
	if err != nil {
		return "", fmt.Errorf("error normalizing exploit name: %v", err)
	}

	if filesystem.IsPath(namePathNormalized) {
		path = namePathNormalized
	} else {
		exploitsDir := filepath.Join(path, "exploits")
		if _, err := os.Stat(exploitsDir); os.IsNotExist(err) {
			logger.Log.Warn().Msg("Exploits directory does not exist, creating it")
			os.Mkdir(exploitsDir, os.ModePerm)
		}
		path = filepath.Join(exploitsDir, namePathNormalized)
	}

	if _, err := os.Stat(path); os.IsNotExist(err) {
		return "", fmt.Errorf("exploit file does not exist: %s", path)
	}

	err = os.Remove(path)
	if err != nil {
		return "", fmt.Errorf("error removing exploit file: %v", err)
	}

	return "Exploit file removed successfully: " + path, nil
}

// ============================================================================
// EXPLOIT PROCESS MANAGEMENT FUNCTIONS
// ============================================================================

// Stop terminates the exploit process with the given PID
func Stop(pid int) (string, error) {
	cm := config.GetConfigManager()
	if err := cm.LoadLocalConfigFromFile(); err != nil {
		return "", err
	}

	for i, exploitS := range cm.GetLocalConfig().Exploits {
		logger.Log.Info().Str("Exploit", exploitS.Name).Msg("Stopping exploit")
		if exploitS.PID == pid {
			proc, err := os.FindProcess(exploitS.PID)
			if err != nil {
				return "", err
			}
			err = proc.Kill()
			if err != nil {
				logger.Log.Error().Err(err).Msg("Error stopping exploit")
				return "", err
			}

			cm.UpdateLocalConfig("", 0, "", cm.GetLocalConfig().HTTPS, slices.Delete(cm.GetLocalConfig().Exploits, i, i+1))

			cm.WriteLocalConfigToFile()
			return "Exploit stopped successfully: " + exploitS.Name, nil
		}
	}
	logger.Log.Warn().Msg("No exploit found with the specified PID")
	return "", fmt.Errorf("no exploit found with PID %d", cm.GetPID())
}

// List retrieves and lists all currently running exploits
func List() (string, error) {
	cm := config.GetConfigManager()
	err := cm.LoadLocalConfigFromFile()
	if err != nil {
		return "", fmt.Errorf("error loading local configuration, try running `cookieclient config reset`: %w", err)
	}

	var result strings.Builder
	result.WriteString("===== Running Exploits =====\n\n")

	count := 0
	filtered := make([]config.Exploit, 0, len(cm.GetLocalConfig().Exploits))
	for _, exploitS := range cm.GetLocalConfig().Exploits {
		logger.Log.Debug().Str("exploit", exploitS.Name).Int("pid", exploitS.PID).Msg("Checking exploit")
		proc, err := os.FindProcess(exploitS.PID)
		if err != nil || proc == nil {
			logger.Log.Warn().Str("exploit", exploitS.Name).Msg("Exploit removed due to invalid or inactive process")
			continue
		}

		if !isProcessRunning(exploitS.PID) {
			logger.Log.Warn().Str("exploit", exploitS.Name).Msg("Exploit removed due to inactive process")
			continue
		}

		count++
		result.WriteString(fmt.Sprintf("  %d. Name: %-30s PID: %d\n", count, filepath.Base(exploitS.Name), exploitS.PID))
		filtered = append(filtered, exploitS)
	}

	localConfig := cm.GetLocalConfig()
	localConfig.Exploits = filtered
	cm.SetLocalConfig(localConfig)
	if err := cm.WriteLocalConfigToFile(); err != nil {
		logger.Log.Error().Err(err).Msg("Failed to write configuration after filtering exploits")
	}

	if count == 0 {
		return "No running exploits found", nil
	}

	result.WriteString(fmt.Sprintf("\nTotal: %d running exploit(s)", count))
	return result.String(), nil
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Cleanup removes an exploit from the configuration
func Cleanup(pid int) {
	cm := config.GetConfigManager()
	localConfig := cm.GetLocalConfig()
	for i, exploit := range localConfig.Exploits {
		if exploit.PID == pid {
			localConfig.Exploits = slices.Delete(localConfig.Exploits, i, i+1)
			break
		}
	}
	if err := cm.WriteLocalConfigToFile(); err != nil {
		logger.Log.Error().Err(err).Msg("Failed to write configuration after exploit cleanup")
	}
}
